{"name":"Common Framework","tagline":"Caelan.Frameworks.Common NuGet Package","body":"#Common Framework\r\nThe Caelan.Frameworks.Common NuGet Package [![NuGet version](https://badge.fury.io/nu/Caelan.Frameworks.Common.svg)](http://badge.fury.io/nu/Caelan.Frameworks.Common)\r\n\r\nIf you need support or you want to contact me I'm [CaelanIt](https://twitter.com/CaelanIt) on Twitter\r\n##Build##\r\nAppVeyor (Windows): [![Build status](https://ci.appveyor.com/api/projects/status/0wi8iemmxy4xu986?svg=true)](https://ci.appveyor.com/project/matteobruni/caelan-frameworks-common)\r\n\r\nTravis CI (Unix Mono): [![Build Status](https://travis-ci.org/Ar3sDevelopment/Caelan.Frameworks.Common.svg?branch=master)](https://travis-ci.org/Ar3sDevelopment/Caelan.Frameworks.Common)\r\n##Requests##\r\nPull Requests: [![Issue Stats](http://issuestats.com/github/Ar3sDevelopment/Caelan.Frameworks.Common/badge/pr)](http://issuestats.com/github/Ar3sDevelopment/Caelan.Frameworks.Common)\r\n\r\nIssues: [![Issue Stats](http://issuestats.com/github/Ar3sDevelopment/Caelan.Frameworks.Common/badge/issue)](http://issuestats.com/github/Ar3sDevelopment/Caelan.Frameworks.Common)\r\n\r\nWaffle.io: [![Stories in Ready](https://badge.waffle.io/Ar3sDevelopment/Caelan.Frameworks.Common.png?label=ready&title=Ready)](https://waffle.io/Ar3sDevelopment/Caelan.Frameworks.Common)\r\n\r\n##What is it?##\r\nMy Framework.Common package is an utility framework for delegating the object mapping to a specific class or simply for a password hasher class.\r\n\r\n##`Builder` and `IMapper<TSource, TDestination>`##\r\nYou can use `Builder` class for map a source to a destination or create a new object from the source like this:\r\n```csharp\r\nvar userDto = Builder.Build(user).To<UserDTO>(); //user is a User instance\r\n```\r\nBut if a `IMapper<User, UserDTO>` implementation is missing it will build an empty `UserDTO`.\r\n`DefaultMapper<TSource, TDestination>` is an abstract class that prepare a simple `IMapper<TSource, TDestination>` implementation, you have only to define a body for `CustomMap(TSource source, TDestination destination)` method, like this:\r\n```csharp\r\npublic class UserDTOMapper : DefaultMapper<User, UserDTO>\r\n{\r\n  public override void CustomMap(User source, UserDTO destination)\r\n  {\r\n    base.Map(source, destination)\r\n    //body here like\r\n    //destination.Member = source.Member;\r\n    return destination;\r\n  }\r\n}\r\n```\r\nAnd you're done. `Builder` class searches for it in assemblies and use it without you have to do nothing more than the `Builder` syntax showed before.\r\nIf `Builder` class can't find it or you have multiple mapper for same types you can specify the mapper like this:\r\n```csharp\r\nvar mapper = new UserDTOMapper();\r\n//if the mapper has some custom property you can initialize them here\r\nvar userDto = Builder.Build(user).To<UserDTO>(mapper); //user is a User instance\r\n```\r\n\r\n##`IPasswordEncryptor`##\r\n`IPasswordEncryptor` is a simple interface with two methods:\r\n```csharp\r\nstring EncryptPassword(string password, string secret, string salt)\r\nstring DecryptPassword(string crypted, string secret, string salt)\r\n```\r\nAnd you can inherit from this for a custom password encryptor and reference it by the interface.\r\nI created a small `PasswordEncryptor` class that provides *AES256* crypting by default.\r\n`PasswordEncryptor` is very simple, you can instantiate like this:\r\n```csharp\r\nconst string defaultPassword = \"Def4ult\";\r\nconst string secret = \"secret\";\r\nconst string salt = \"saltsalt\"; //lenght must be at least 8\r\nvar encryptor = new PasswordEncryptor(defaultPassword, secret, salt);\r\n//and now you know how to encrypt\r\nvar crypted = encryptor.EncryptPassword(\"123456789\");\r\n//and now you know how to decrypt\r\nvar original = encryptor.DecryptPassword(crypted);\r\n```\r\n\r\n##`IPasswordHasher`##\r\n`IPasswordHasher` is a simple interface with one method:\r\n```csharp\r\nstring HashPassword(string password)\r\n```\r\nAnd you can inherit from this for a custom password encryptor and reference it by the interface.\r\nI created a small `PasswordHasher` class that provides *SHA512* hasing with a salt.\r\n`PasswordEncryptor` is very simple, you can instantiate like this:\r\n```csharp\r\nconst string salt = \"Salty\";\r\nconst string defaultPassword = \"Def4ult\";\r\nvar encryptor = new PasswordHasher(salt, defaultPassword);\r\n//and now you know how to encrypt\r\nencryptor.HashPassword(\"123456789\");\r\n```\r\n","google":"UA-57981518-1","note":"Don't delete this file! It's used internally to help with page regeneration."}